-- =====================================================
-- PixelForge Nexus — Database Schema Migration
-- Secure Design: RLS, role-based access, audit trails
-- =====================================================
-- NOTE: Tables are created first, then SECURITY DEFINER
-- helper functions, then policies — to avoid forward
-- references and infinite RLS recursion.
-- =====================================================

-- =====================================================
-- 1. ENUMS
-- =====================================================
CREATE TYPE public.app_role AS ENUM ('admin', 'project_lead', 'developer');
CREATE TYPE public.project_status AS ENUM ('active', 'completed');

-- =====================================================
-- 2. ALL TABLES (created before any policies)
-- =====================================================

-- Profiles (extends auth.users)
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name TEXT NOT NULL,
  email TEXT NOT NULL,
  avatar_url TEXT,
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT now() NOT NULL
);
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- User Roles
CREATE TABLE public.user_roles (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role public.app_role NOT NULL DEFAULT 'developer',
  UNIQUE (user_id, role)
);
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;

-- Projects
CREATE TABLE public.projects (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT NOT NULL DEFAULT '',
  deadline TIMESTAMPTZ NOT NULL,
  status public.project_status NOT NULL DEFAULT 'active',
  created_by UUID NOT NULL REFERENCES auth.users(id),
  lead_id UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT now() NOT NULL
);
ALTER TABLE public.projects ENABLE ROW LEVEL SECURITY;

-- Project Members
CREATE TABLE public.project_members (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  project_id UUID NOT NULL REFERENCES public.projects(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  assigned_by UUID NOT NULL REFERENCES auth.users(id),
  assigned_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  UNIQUE (project_id, user_id)
);
ALTER TABLE public.project_members ENABLE ROW LEVEL SECURITY;

-- Documents
CREATE TABLE public.documents (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  project_id UUID NOT NULL REFERENCES public.projects(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  current_version INT NOT NULL DEFAULT 1,
  created_by UUID NOT NULL REFERENCES auth.users(id),
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT now() NOT NULL
);
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;

-- Document Versions
CREATE TABLE public.document_versions (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  document_id UUID NOT NULL REFERENCES public.documents(id) ON DELETE CASCADE,
  version INT NOT NULL,
  storage_path TEXT NOT NULL,
  file_name TEXT NOT NULL,
  file_size BIGINT NOT NULL DEFAULT 0,
  mime_type TEXT NOT NULL DEFAULT 'application/octet-stream',
  uploaded_by UUID NOT NULL REFERENCES auth.users(id),
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  UNIQUE (document_id, version)
);
ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;

-- =====================================================
-- 3. INDEXES for RLS Performance
-- =====================================================
CREATE INDEX idx_user_roles_user_id ON public.user_roles(user_id);
CREATE INDEX idx_projects_lead_id ON public.projects(lead_id);
CREATE INDEX idx_projects_status ON public.projects(status);
CREATE INDEX idx_project_members_user_id ON public.project_members(user_id);
CREATE INDEX idx_project_members_project_id ON public.project_members(project_id);
CREATE INDEX idx_documents_project_id ON public.documents(project_id);
CREATE INDEX idx_document_versions_document_id ON public.document_versions(document_id);

-- =====================================================
-- 4. SECURITY DEFINER HELPER FUNCTIONS
-- These bypass RLS internally, breaking circular
-- policy references between projects <-> project_members
-- =====================================================

-- Returns project IDs where the current user is a member
CREATE OR REPLACE FUNCTION public.get_my_project_ids()
RETURNS SETOF UUID
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = ''
AS $$
  SELECT project_id FROM public.project_members WHERE user_id = auth.uid();
$$;

-- Returns project IDs where the current user is the lead
CREATE OR REPLACE FUNCTION public.get_my_led_project_ids()
RETURNS SETOF UUID
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = ''
AS $$
  SELECT id FROM public.projects WHERE lead_id = auth.uid();
$$;

-- Returns document IDs belonging to projects the current user leads
CREATE OR REPLACE FUNCTION public.get_my_led_document_ids()
RETURNS SETOF UUID
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = ''
AS $$
  SELECT d.id FROM public.documents d
  JOIN public.projects p ON d.project_id = p.id
  WHERE p.lead_id = auth.uid();
$$;

-- =====================================================
-- 5. RLS POLICIES (using helper functions to avoid recursion)
-- =====================================================

-- ----- PROFILES POLICIES -----
CREATE POLICY "Authenticated users can read all profiles"
  ON public.profiles FOR SELECT
  TO authenticated
  USING (true);

CREATE POLICY "Users can update own profile"
  ON public.profiles FOR UPDATE
  TO authenticated
  USING ((SELECT auth.uid()) = id)
  WITH CHECK ((SELECT auth.uid()) = id);

CREATE POLICY "Service role can insert profiles"
  ON public.profiles FOR INSERT
  TO authenticated
  WITH CHECK ((SELECT auth.uid()) = id);

-- ----- USER ROLES POLICIES -----
CREATE POLICY "Authenticated users can read all roles"
  ON public.user_roles FOR SELECT
  TO authenticated
  USING (true);

CREATE POLICY "Admins can insert roles"
  ON public.user_roles FOR INSERT
  TO authenticated
  WITH CHECK (
    (SELECT (auth.jwt() ->> 'user_role')) = 'admin'
  );

CREATE POLICY "Admins can update roles"
  ON public.user_roles FOR UPDATE
  TO authenticated
  USING (
    (SELECT (auth.jwt() ->> 'user_role')) = 'admin'
  );

CREATE POLICY "Admins can delete roles"
  ON public.user_roles FOR DELETE
  TO authenticated
  USING (
    (SELECT (auth.jwt() ->> 'user_role')) = 'admin'
  );

-- ----- PROJECTS POLICIES -----
CREATE POLICY "Admins full access to projects"
  ON public.projects FOR ALL
  TO authenticated
  USING (
    (SELECT (auth.jwt() ->> 'user_role')) = 'admin'
  )
  WITH CHECK (
    (SELECT (auth.jwt() ->> 'user_role')) = 'admin'
  );

CREATE POLICY "Project leads can view their projects"
  ON public.projects FOR SELECT
  TO authenticated
  USING (
    (SELECT (auth.jwt() ->> 'user_role')) = 'project_lead'
    AND lead_id = (SELECT auth.uid())
  );

CREATE POLICY "Project leads can update their projects"
  ON public.projects FOR UPDATE
  TO authenticated
  USING (
    (SELECT (auth.jwt() ->> 'user_role')) = 'project_lead'
    AND lead_id = (SELECT auth.uid())
  )
  WITH CHECK (
    (SELECT (auth.jwt() ->> 'user_role')) = 'project_lead'
    AND lead_id = (SELECT auth.uid())
  );

-- Uses get_my_project_ids() to avoid recursion with project_members
CREATE POLICY "Developers can view assigned projects"
  ON public.projects FOR SELECT
  TO authenticated
  USING (
    (SELECT (auth.jwt() ->> 'user_role')) = 'developer'
    AND id IN (SELECT public.get_my_project_ids())
  );

CREATE POLICY "Project leads can view assigned projects"
  ON public.projects FOR SELECT
  TO authenticated
  USING (
    (SELECT (auth.jwt() ->> 'user_role')) = 'project_lead'
    AND id IN (SELECT public.get_my_project_ids())
  );

-- ----- PROJECT MEMBERS POLICIES -----
CREATE POLICY "Admins full access to project_members"
  ON public.project_members FOR ALL
  TO authenticated
  USING (
    (SELECT (auth.jwt() ->> 'user_role')) = 'admin'
  )
  WITH CHECK (
    (SELECT (auth.jwt() ->> 'user_role')) = 'admin'
  );

-- Uses get_my_led_project_ids() to avoid recursion with projects
CREATE POLICY "Project leads can manage members of their projects"
  ON public.project_members FOR ALL
  TO authenticated
  USING (
    (SELECT (auth.jwt() ->> 'user_role')) = 'project_lead'
    AND project_id IN (SELECT public.get_my_led_project_ids())
  )
  WITH CHECK (
    (SELECT (auth.jwt() ->> 'user_role')) = 'project_lead'
    AND project_id IN (SELECT public.get_my_led_project_ids())
  );

-- Uses get_my_project_ids() to avoid self-referencing recursion
CREATE POLICY "Developers can view members of their projects"
  ON public.project_members FOR SELECT
  TO authenticated
  USING (
    project_id IN (SELECT public.get_my_project_ids())
  );

-- ----- DOCUMENTS POLICIES -----
CREATE POLICY "Admins full access to documents"
  ON public.documents FOR ALL
  TO authenticated
  USING (
    (SELECT (auth.jwt() ->> 'user_role')) = 'admin'
  )
  WITH CHECK (
    (SELECT (auth.jwt() ->> 'user_role')) = 'admin'
  );

-- Uses get_my_led_project_ids() to avoid recursion
CREATE POLICY "Project leads can manage documents of their projects"
  ON public.documents FOR ALL
  TO authenticated
  USING (
    project_id IN (SELECT public.get_my_led_project_ids())
  )
  WITH CHECK (
    project_id IN (SELECT public.get_my_led_project_ids())
  );

CREATE POLICY "Members can view documents of their projects"
  ON public.documents FOR SELECT
  TO authenticated
  USING (
    project_id IN (SELECT public.get_my_project_ids())
  );

-- ----- DOCUMENT VERSIONS POLICIES -----
CREATE POLICY "Admins full access to document_versions"
  ON public.document_versions FOR ALL
  TO authenticated
  USING (
    (SELECT (auth.jwt() ->> 'user_role')) = 'admin'
  )
  WITH CHECK (
    (SELECT (auth.jwt() ->> 'user_role')) = 'admin'
  );

-- Uses get_my_led_document_ids() to avoid recursion
CREATE POLICY "Project leads can manage versions of their project docs"
  ON public.document_versions FOR ALL
  TO authenticated
  USING (
    document_id IN (SELECT public.get_my_led_document_ids())
  )
  WITH CHECK (
    document_id IN (SELECT public.get_my_led_document_ids())
  );

CREATE POLICY "Members can view versions of their project docs"
  ON public.document_versions FOR SELECT
  TO authenticated
  USING (
    document_id IN (
      SELECT d.id FROM public.documents d
      WHERE d.project_id IN (SELECT public.get_my_project_ids())
    )
  );

-- =====================================================
-- 6. TRIGGERS
-- =====================================================

-- Auto-update updated_at timestamp
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_profiles_updated_at
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

CREATE TRIGGER set_projects_updated_at
  BEFORE UPDATE ON public.projects
  FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

CREATE TRIGGER set_documents_updated_at
  BEFORE UPDATE ON public.documents
  FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

-- Auto-create profile when a new user signs up
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, email)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data ->> 'full_name', NEW.email),
    NEW.email
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- =====================================================
-- 7. CUSTOM ACCESS TOKEN HOOK (injects user_role into JWT)
-- =====================================================
CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event JSONB)
RETURNS JSONB
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
  claims JSONB;
  user_role public.app_role;
BEGIN
  -- Fetch the user's role from the user_roles table
  SELECT role INTO user_role
  FROM public.user_roles
  WHERE user_id = (event ->> 'user_id')::UUID
  LIMIT 1;

  claims := event -> 'claims';

  IF user_role IS NOT NULL THEN
    -- Set the user_role claim in the JWT
    claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
  ELSE
    -- No role found — set to null
    claims := jsonb_set(claims, '{user_role}', 'null');
  END IF;

  -- Update the claims in the event
  event := jsonb_set(event, '{claims}', claims);
  RETURN event;
END;
$$;

-- Grant permissions for the auth hook
GRANT USAGE ON SCHEMA public TO supabase_auth_admin;
GRANT EXECUTE ON FUNCTION public.custom_access_token_hook TO supabase_auth_admin;
REVOKE EXECUTE ON FUNCTION public.custom_access_token_hook FROM authenticated, anon, public;
GRANT ALL ON TABLE public.user_roles TO supabase_auth_admin;

-- Allow auth admin to read user roles for the hook
CREATE POLICY "Allow auth admin to read user roles"
  ON public.user_roles AS PERMISSIVE
  FOR SELECT TO supabase_auth_admin
  USING (true);

-- =====================================================
-- 8. HELPER FUNCTION — Create document version atomically
-- =====================================================
CREATE OR REPLACE FUNCTION public.create_document_version(
  p_document_id UUID,
  p_version INT,
  p_storage_path TEXT,
  p_file_name TEXT,
  p_file_size BIGINT,
  p_mime_type TEXT,
  p_uploaded_by UUID
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_version_id UUID;
BEGIN
  -- Insert the new version
  INSERT INTO public.document_versions
    (document_id, version, storage_path, file_name, file_size, mime_type, uploaded_by)
  VALUES
    (p_document_id, p_version, p_storage_path, p_file_name, p_file_size, p_mime_type, p_uploaded_by)
  RETURNING id INTO v_version_id;

  -- Update the document's current version
  UPDATE public.documents
  SET current_version = p_version, updated_at = now()
  WHERE id = p_document_id;

  RETURN v_version_id;
END;
$$;

-- =====================================================
-- 9. STORAGE BUCKET
-- =====================================================
-- Create the documents bucket
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'documents',
  'documents',
  false,
  52428800, -- 50MB limit
  ARRAY['application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'application/vnd.ms-powerpoint', 'application/vnd.openxmlformats-officedocument.presentationml.presentation', 'text/plain', 'text/markdown', 'image/png', 'image/jpeg', 'image/gif', 'image/webp', 'application/zip', 'application/json']
) ON CONFLICT (id) DO NOTHING;

-- Storage policies
CREATE POLICY "Admins can upload to any project"
  ON storage.objects FOR INSERT
  TO authenticated
  WITH CHECK (
    bucket_id = 'documents'
    AND (SELECT (auth.jwt() ->> 'user_role')) = 'admin'
  );

CREATE POLICY "Project leads can upload to their projects"
  ON storage.objects FOR INSERT
  TO authenticated
  WITH CHECK (
    bucket_id = 'documents'
    AND (SELECT (auth.jwt() ->> 'user_role')) = 'project_lead'
  );

CREATE POLICY "Authenticated users can read documents bucket"
  ON storage.objects FOR SELECT
  TO authenticated
  USING (
    bucket_id = 'documents'
  );

CREATE POLICY "Admins can delete from documents bucket"
  ON storage.objects FOR DELETE
  TO authenticated
  USING (
    bucket_id = 'documents'
    AND (SELECT (auth.jwt() ->> 'user_role')) = 'admin'
  );

CREATE POLICY "Project leads can delete from their documents"
  ON storage.objects FOR DELETE
  TO authenticated
  USING (
    bucket_id = 'documents'
    AND (SELECT (auth.jwt() ->> 'user_role')) = 'project_lead'
  );

-- =====================================================
-- 10. BACKFILL PROFILES for existing auth users
-- =====================================================
INSERT INTO public.profiles (id, full_name, email)
SELECT
  id,
  COALESCE(raw_user_meta_data ->> 'full_name', email),
  email
FROM auth.users
WHERE id NOT IN (SELECT id FROM public.profiles)
ON CONFLICT (id) DO NOTHING;
